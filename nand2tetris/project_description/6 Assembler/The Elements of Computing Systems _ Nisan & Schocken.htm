<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0029)http://nand2tetris.org/06.php -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
	<title>The Elements of Computing Systems / Nisan &amp; Schocken</title>
		<link rel="stylesheet" type="text/css" href="./The Elements of Computing Systems _ Nisan &amp; Schocken_files/style.css">
		<script type="text/javascript" src="./The Elements of Computing Systems _ Nisan &amp; Schocken_files/jquery-1.7.1.min.js"></script>		
		<script type="text/javascript" src="./The Elements of Computing Systems _ Nisan &amp; Schocken_files/popup.js"></script></head><body><div id="nand_popup" onmouseover="overPopup(true);" onmouseout="overPopup(false);" style="display: none; z-index: 200; top: 607px; left: 782px;"></div>		
	
	
		<div class="box">
					
				<a name="top"></a>
				<div class="topbar">
<img class="banner" src="./The Elements of Computing Systems _ Nisan &amp; Schocken_files/banner.png" height="100px" alt="Banner">
<span class="titletext">From NAND to Tetris</span>
<span class="subtitletext">Building a Modern Computer From First
Principles</span>
</div>
				<div class="sidemenu">
					<a href="http://nand2tetris.org/" class="menu">Home</a><a href="http://nand2tetris.org/course.php" class="menu_selected">Course</a><a href="http://nand2tetris.org/book.php" class="menu">Book</a><a href="http://nand2tetris.org/software.php" class="menu">Software</a><a href="http://nand2tetris.org/terms.php" class="menu">License</a><a href="http://nand2tetris.org/papers.php" class="menu">Papers</a><a href="http://nand2tetris.org/media.php" class="menu">Talks</a><a href="http://nand2tetris.org/coolstuff.php" class="menu">Cool Stuff</a><a href="http://nand2tetris.org/about.php" class="menu">About</a><a href="http://nand2tetris.org/team.php" class="menu">Team</a><a href="https://docs.google.com/forms/d/e/1FAIpQLSeGtR3QyvmjMubq3ij3h7CBKvDSxd9nnHhkLVZR4YB5FVo8sA/viewform" target="_blank" "="" class="menu">Stay in Touch</a><a href="http://questions-and-answers-forum.32033.n3.nabble.com/" target="_blank" "="" class="menu">Q&amp;A</a>				</div>
			<div class="content">
			<h1>Project 6: The Assembler</h1>
<span class="project_desc">Background</span>
<p class="project_text">
Low-level machine programs are rarely written by humans. Typically, they are generated by compilers. Yet humans can inspect the translated code and learn important lessons about how to write their high-level programs better, in a way that avoids low-level pitfalls and exploits the underlying hardware better. One of the key players in this translation process is the <i>assembler</i> -- a program designed to translate code written in a symbolic machine language into code written in binary machine language.
</p>

<p class="project_text">
This project marks an exciting landmark in our <i>Nand to Tetris</i> odyssey: it deals with building the first rung up the software hierarchy, which will eventually end up in the construction of a compiler for a Java-like high-level language. But, first things first.
</p>

<span class="project_desc">Objective</span>
<p class="project_text">
Write an Assembler program that translates programs written in the symbolic Hack assembly language into binary code that can execute on the Hack hardware platform built in the previous projects.
</p>

<span class="project_desc">Contract</span>
<p class="project_text">
There are three ways to describe the desired behavior of your assembler: (i) When loaded into your assembler, a <span class="code">Prog.asm</span> file containing a valid Hack assembly language program should be translated into the correct Hack binary code and stored in a <span class="code">Prog.hack</span> file. (ii) The output produced by your assembler must be identical to the output produced by the <i>Assembler</i> supplied with the <i>Nand2Tetris Software Suite</i>. (iii) Your assembler must implement the translation specification given in Chapter 6, Section 2.
</p>

<span class="project_desc">Usage</span>
<p class="project_text">Depending on the programming language that you use, the assembler should be invoked using something like "<tt>Assembler</tt> <i>fileName</i><tt>.asm</tt>", where the string <i>fileName</i><tt>.asm</tt> is the assembler's input, i.e. the name of a text file containing Hack assembly commands. The assembler creates an output text file named <i>fileName</i><tt>.hack</tt>. Each line in the output file consists of sixteen 0 and 1 characters. The output file is stored in the same directory of the input file. The name of the input file may contain a file path.
</p>

<span class="project_desc">Resources</span>
<p class="project_text">
The relevant reading for this project is <a target="_blank" href="http://nand2tetris.org/chapters/chapter%2006.pdf">Chapter 6</a>. Your assembler implementation can be written in any programming language (<i>Java</i> and <i>Python</i> being popular choices). Two useful tools are the supplied <i>Assembler</i> and the supplied <i>CPU Emulator</i>, both available in your <span class="code">tools</span> directory. These tools allow experimenting with a working assembler before setting out to build one yourself. In addition, the supplied assembler provides a visual line-level translation GUI, and allows code comparisons with the outputs that <i>your</i> assembler will generate. For more information about these capabilities, refer to the supplied <i>Assembler Tutorial</i> ( <a href="http://nand2tetris.org/tutorials/PPT/Assembler%20Tutorial.ppt"><img align="ABSMIDDLE" src="./The Elements of Computing Systems _ Nisan &amp; Schocken_files/powerpoint.gif" alt="PowerPoint Format" width="16" height="16"></a> <a href="http://nand2tetris.org/tutorials/PDF/Assembler%20Tutorial.pdf"><img align="ABSMIDDLE" src="./The Elements of Computing Systems _ Nisan &amp; Schocken_files/acrobat.gif" alt="Portable Document Format" width="16" height="16"></a> )
</p>

<span class="project_desc">Proposed Implementation</span>
<p class="project_text">
Chapter 6 includes a proposed, language-independent <i>Assembler API</i>, which can serve as your implementation's blueprint. We suggest building the assembler in two stages. First, write a basic assembler designed to translate assembly programs that contain no symbols. Next, extend your basic assembler with symbol handling capabilities, yielding the final assembler. The test programs that we supply below are designed to support this staged implementation strategy.
</p>

<span class="project_desc">Test Programs</span>
<p class="project_text">
Each test program except the first one comes in two versions: <span class="code"> Prog.asm </span> is an assembly program; <span class="code"> ProgL.asm </span> is the very same program, Less the symbols (each symbol is replaced with an explicit memory address).
</p>
<table class="tests">
<tbody><tr class="tblheader"> 
	<td>Symbolic Program</td>
	<td>Without Symbols</td>
	<td>Description</td>
</tr> 
<tr> 
	<td> <a onmouseover="popup(&quot;projects/06/add/Add.asm&quot;,true);"> Add.asm </a> </td>
	<td> &nbsp;</td>
	<td> Adds up the constants 2 and 3 and puts the result in <span class="code">R0</span>.</td>	
</tr>
<tr> 
	<td> <a onmouseover="popup(&quot;projects/06/max/Max.asm&quot;,true);"> Max.asm </a> </td>
	<td> <a onmouseover="popup(&quot;projects/06/max/MaxL.asm&quot;,true);"> MaxL.asm </a> </td>
	<td> Computes <span class="code">max(R0,R1)</span> and puts the result in R2.</td>
</tr>
<tr>
	<td> <a onmouseover="popup(&quot;projects/06/rect/Rect.asm&quot;,true);"> Rect.asm </a> </td>
	<td> <a onmouseover="popup(&quot;projects/06/rect/RectL.asm&quot;,true);"> RectL.asm </a> </td>
	<td> Draws a rectangle at the top-left corner of the screen. The rectangle is 16 pixels wide and <span class="code">R0</span> pixels high.</td>
</tr>

<tr> 
	<td> <a onmouseover="popup(&quot;projects/06/pong/Pong.asm&quot;,true);"> Pong.asm </a> </td>
	<td> <a onmouseover="popup(&quot;projects/06/pong/PongL.asm&quot;,true);"> PongL.asm </a> </td>
	<td> A single-player <i>Pong</i> game. A ball bounces off the screen's "walls". The player attempts to hit the ball with a paddle by pressing the <i>left</i> and <i>right</i> arrow keyboard keys. For each successful hit, the player gains one point and the paddle shrinks a little, to make the game slightly more challenging. If the player misses the ball, the game is over. To quit the game, press the <span class="code">ESC</span> key.</td>	
</tr>
</tbody></table>

<p class="project_text">
<b>The <i>Pong</i> program</b> supplied above was written in the Java-like high-level <i>Jack</i> language and translated into the Hack assembly language by the Jack compiler (Jack and the Jack compiler are described in Chapter 9 and in Chapters 10-11, respectively). Although the original Jack program is only about 300 lines of Jack code, the executable <i>Pong</i> code is naturally much longer. Running this interactive program in the supplied <i>CPU Emulator</i> is a slow affair, so don't expect a high-powered Pong game. This slowness is actually a virtue, since it enables your eye to track the graphical behavior of the program. And don't worry! as we continue to build the software platform in the next few projects, <i>Pong</i> and and other games will run much faster.
</p>

<span class="project_desc">Tools</span>
<p class="project_text">
<b>The supplied Hack Assembler</b> shown below is guaranteed to generate correct binary code. This guaranteed performance can be used to test if another assembler, say the one written by you, also generates correct code. The following screen shot illustrates the comparison process:
</p>

<img src="./The Elements of Computing Systems _ Nisan &amp; Schocken_files/Assembler comparing.gif">

<p class="project_text">
<b>The comparison logic:</b> Let <span class="code">Prog.asm</span> <span> be some program written in the symbolic Hack assembly language. Suppose we translate this program using the supplied assembler, producing a binary file called <span class="code">Prog.hack</span>. Next, we use another assembler (e.g. the one that you wrote) to translate the same program into another file, say <span class="code"> MyProg.hack</span>. Now, if the latter assembler is working correctly, it follows that <span class="code">Prog.hack == MyProg.hack</span>. Thus, one way to test a newly written assembler is as follows: (i) load into the supplied visual assembler <span class="code">Prog.asm</span> as a source program and <span class="code">MyProg.hack</span> as a <i>compare file</i>, (ii) translate the source program, and (iii) compare the resulting binary code with the compare file (see the figure above). If the comparison fails, the assembler that generated <span class="code">MyProg.hack</span> must be buggy; otherwise, it may be OK.  
</span></p>
	
			</div>
		</div>
		<div class="small">
			Best viewed with 
							<img src="./The Elements of Computing Systems _ Nisan &amp; Schocken_files/compatible_firefox.gif">
							<img src="./The Elements of Computing Systems _ Nisan &amp; Schocken_files/compatible_chrome.gif"><br>
			Designed and built by Tali Gutman ©
		</div>
	
	
</body></html>