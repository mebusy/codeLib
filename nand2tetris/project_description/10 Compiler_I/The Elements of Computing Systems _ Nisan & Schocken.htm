<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0029)http://nand2tetris.org/10.php -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
	<title>The Elements of Computing Systems / Nisan &amp; Schocken</title>
		<link rel="stylesheet" type="text/css" href="./The Elements of Computing Systems _ Nisan &amp; Schocken_files/style.css">
		<script type="text/javascript" src="./The Elements of Computing Systems _ Nisan &amp; Schocken_files/jquery-1.7.1.min.js"></script>		
		<script type="text/javascript" src="./The Elements of Computing Systems _ Nisan &amp; Schocken_files/popup.js"></script></head><body><div id="nand_popup" onmouseover="overPopup(true);" onmouseout="overPopup(false);" style="display: none; z-index: 200; top: 257px; left: 1062px;"></div>		
	
	
		<div class="box">
					
				<a name="top"></a>
				<div class="topbar">
<img class="banner" src="./The Elements of Computing Systems _ Nisan &amp; Schocken_files/banner.png" height="100px" alt="Banner">
<span class="titletext">From NAND to Tetris</span>
<span class="subtitletext">Building a Modern Computer From First
Principles</span>
</div>
				<div class="sidemenu">
					<a href="http://nand2tetris.org/" class="menu">Home</a><a href="http://nand2tetris.org/course.php" class="menu_selected">Course</a><a href="http://nand2tetris.org/book.php" class="menu">Book</a><a href="http://nand2tetris.org/software.php" class="menu">Software</a><a href="http://nand2tetris.org/terms.php" class="menu">License</a><a href="http://nand2tetris.org/papers.php" class="menu">Papers</a><a href="http://nand2tetris.org/media.php" class="menu">Talks</a><a href="http://nand2tetris.org/coolstuff.php" class="menu">Cool Stuff</a><a href="http://nand2tetris.org/about.php" class="menu">About</a><a href="http://nand2tetris.org/team.php" class="menu">Team</a><a href="https://docs.google.com/forms/d/e/1FAIpQLSeGtR3QyvmjMubq3ij3h7CBKvDSxd9nnHhkLVZR4YB5FVo8sA/viewform" target="_blank" "="" class="menu">Stay in Touch</a><a href="http://questions-and-answers-forum.32033.n3.nabble.com/" target="_blank" "="" class="menu">Q&amp;A</a>				</div>
			<div class="content">
			<h1>Project 10: Compiler I - Syntax Analysis</h1>
<span class="project_desc">Background</span>
<p class="project_text">
The Jack compiler, like those of Java and C#, is <i>two-tiered</i>: the compiler's <i>front-end</i> translates from the high-level language to an intermediate VM language; the compiler's <i>back-end</i> translates further from the VM language to the native code of the host platform. In projects 7-8 we've built the compiler's back-end (the <i>VM translator</i>); we now turn to building the compiler's front-end. This development will span two projects: <i>syntax analysis</i> (this project), and <i>code generation</i> (next project). Welcome to syntax analysis.
</p>

<span class="project_desc">Objective</span>
<p class="project_text">
In this project we build a <i>syntax analyzer</i> that parses Jack programs according to the Jack grammar, producing an XML file that renders the program's structure using marked-up text. In the next project, the logic that generates the XML output will be morphed into logic that generates VM code.
</p>

<span class="project_desc">Contract</span>
<p class="project_text">
Write a <i>syntax analyzer</i> for the Jack language. Use it to parse all the <span class="code">.jack</span> class files supplied below. For each input <span class="code">.jack</span> file, your analyzer should generate an <span class="code">.xml</span> output file. The generated files should be identical to the supplied compare-files, up to white space.
</p>

<span class="project_desc">Resources</span>
<p class="project_text">
The relevant reading for this project is book chapter 10. You will need two tools: the programming language with which you will implement your <i>syntax analyzer</i>, and the supplied <i>TextComparer</i> utility, available in your <span class="code">nand2tetris/tools</span> directory. This program will help you compare the output files generated by your syntax analyzer to the compare files supplied by us. You may also want to inspect the generated and supplied output files visually, using some XML viewer. To do so, simply load these files into some web browser or text editor. Some of these tools, e.g. Chrome, are designed to display XML text nicely - give it a try. All the files necessary for this project are available in <span class="code">nand2tetris/projects/10</span> on your computer.  
</p>

<span class="project_desc">Proposed Implementation</span>

<p class="project_text">
Chapter 10 includes a proposed, language-independent <i>syntax analyzer API</i>, which can serve as your implementation's blueprint. We propose implementing the syntax analyzer in two stages. First, write and test the <i>Tokenizer</i> module. Next, write and test the <i>CompilationEngine</i> module, which implements the parser described in the chapter.
</p>

<u><b>Stage I: Tokenizer</b></u> <br>

<p class="project_text">
<i>Tokenizing</i>, a basic service of any syntax alayzer, is the act of breaking a given textual input into a stream of tokens. And while it is at it, the tokenizer can also classify the tokens into lexical categories. With that in mind, your first task it to implement, and test, the <span class="code">JackTokenizer</span> module specified in chapter 10. Specifically, you have to develop (i) a Tokenizer implementation, and (ii) a test program that goes through a given input file (<span class="code">.jack</span> file) and produces a stream of tokens using your Tokenizer implementation. Each token should be printed in a separate line, along with its classification: <i>symbol</i>, <i>keyword</i>, <i>identifier</i>, <i>integer constant</i> or <i>string constant</i>. Here is an example: 
</p>

<table class="tests">
<tbody><tr class="tstheader">
	<td> Source code (input) </td>
	<td> Tokenizer output </td> 
</tr>
<tr>
	<td> <span class="code"> if (x &lt; 0) <br>&nbsp;&nbsp;{let state = "negative";} </span> </td>
<td> <pre class="code">&lt;tokens&gt;
   &lt;keyword&gt; if &lt;/keyword&gt;
   &lt;symbol&gt; ( &lt;/symbol&gt;
   &lt;identifier&gt; x &lt;/identifier&gt;
   &lt;symbol&gt; &amp;lt; &lt;/symbol&gt;
   &lt;integerConstant&gt; 0 &lt;/integerConstant&gt;
   &lt;symbol&gt; ) &lt;/symbol&gt;
   &lt;symbol&gt; { &lt;/symbol&gt;
   &lt;keyword&gt; let &lt;/keyword&gt;
   &lt;identifier&gt; state &lt;/identifier&gt;
   &lt;symbol&gt; = &lt;/symbol&gt;
   &lt;stringConstant&gt; negative &lt;/stringConstant&gt;
   &lt;symbol&gt; ; &lt;/symbol&gt;
   &lt;symbol&gt; } &lt;/symbol&gt;
&lt;/tokens&gt;
<pre> </pre></pre></td>
</tr>
</tbody></table>

<p class="project_text">
Note that in the case of string constants, the tokenizer throws away the double-quote characters. This behavior is intended, and is part of our tokenizer specification.
</p>

<p class="project_text">
Also note that four of the symbols used in the Jack language (<span class="code">&lt;</span>, <span class="code">&gt;</span>, <span class="code">"</span>, and <span class="code">&amp;</span>) are also used for XML markup, and thus they cannot appear verbatim as XML data. To solve the problem, and following convention, we require the tokenizer to output these tokens as <span class="code">&amp;lt;</span>, <span class="code">&amp;gt;</span>, <span class="code">&amp;quot;</span>, and <span class="code">&amp;amp;</span>, respectively. For example, in order for the text "<span class="code">&lt;symbol&gt; &lt; &lt;/symbol&gt;</span>" to be displayed properly in a web
browser, it should be generated as "<span class="code">&lt;symbol&gt;&amp;lt;&lt;/symbol&gt;</span>".
</p>

<p class="project_text">
Finally, note that unlike the Tokeinizer module, the tokenizer test program that you are to write is not part of the syntax analyzer. This test program entails an intermediate testing stage, focusing on unit-testing the Tokenizer only. Once this test is completed successfully, the test program is no longer necessary.
</p>

<u><b>Stage II: Parser (<span class="code">CompilationEngine</span>)</b></u> <br>

<p class="project_text">
In the context of this project, <i>parsing</i> is defined narrowly as the act of going over the tokenized input and rendering its grammatical structure using some agreed-upon format. The specific parser that we implement here is based on the Jack grammar, and is designed to emit XML output. Both the grammar and the agreed-upon XML tags are described in chapter 10.
<br><br>
The Jack parser is implemented by the <span class="code">CompilationEngine</span> module, whose API is given in chapter 10. Your task is to implement this API: write each one of the specified methods, and make sure that it emits the correct XML output. For the benfit of unit-testing, we recommend to begin by first writing a compilation engine that handles any given Jack code except for <i>expressions</i>; next, extend it to handle expressions as well. The test programs supplied below are designed to support this staged testing strategy.
</p>

<span class="project_desc">Test Programs</span>
<p class="project_text">
A natural way to test your syntax analyzer it is to have it parse some representative Jack programs. We supply two such test programs: <i>Square Dance</i> and <i>Array Test</i>. The former includes all the syntactic features of the Jack language except for array processing, which appears in the latter. We also provide an expression-less version of the <i>Square Dance</i> program, as explained below.
</p>

<p class="project_text">
<u><b>Square Dance:</b></u> a simple interactive game, described in project 9. The game implementation is organized in three classes:
</p>

<table class="tests">
<tbody><tr class="tstheader">
	<td> Source class file </td>
	<td> Description (quite irrelevant to this project)</td> 
	<td> Tokenizer output </td> 
	<td> Parser output </td>
</tr>
<tr>
	<td>  <a onmouseover="popup(&quot;projects/10/Square/Main.jack&quot;,true);"> Main.jack </a> </td>
	<td> Initializes and starts a new "square moving session".  </td>
	<td> <a onmouseover="popup(&quot;projects/10/Square/MainT.xml&quot;,true);"> MainT.xml </a> </td>
	<td> <a onmouseover="popup(&quot;projects/10/Square/Main.xml&quot;,true);"> Main.xml </a> </td>
</tr>
<tr>
	<td> <a onmouseover="popup(&quot;projects/10/Square/Square.jack&quot;,true);"> Square.jack </a> </td>
	<td> Implements an animated square. A Square object has a screen location and size properties, and methods for drawing, erasing,moving, and size changing.</td> 
	<td> <a onmouseover="popup(&quot;projects/10/Square/SquareT.xml&quot;,true);"> SquareT.xml </a> </td> 
	<td> <a onmouseover="popup(&quot;projects/10/Square/Square.xml&quot;,true);"> Square.xml </a> </td>
</tr> 
<tr>
	<td> <a onmouseover="popup(&quot;projects/10/Square/SquareGame.jack&quot;,true);"> SquareGame.jack </a> </td>
	<td> Runs the show according to the game rules.</td> 
	<td> <a onmouseover="popup(&quot;projects/10/Square/SquareGameT.xml&quot;,true);"> SquareGameT.xml </a> </td>
	<td> <a onmouseover="popup(&quot;projects/10/Square/SquareGame.xml&quot;,true);"> SquareGame.xml </a> </td>
</tr>
</tbody></table>

<p class="project_text">
<b>Note:</b> The three source Jack files comprising the Square Dance game are identical to those stored in the <span class="code">projects/09/Square</span> directory. For completeness, an identical copy of these files is also available in the <span class="code">projects/10/Square</span> directory.
</p>

<p class="project_text">
<u><b>Expressionless Square Dance:</b></u> in this version of <i>Square Dance</i>, each expression in the original source code has been replaced with a single identifier (some variable name in scope). This version of the program was designed in order to facilitate unit-testing of your syntax analyzer's ability to parse everything except for expressions. Note that the replacement of expressions with variables has resulted in nonsensical code which, nonetheless, is grammatically correct. For convenience, the expressionless files have the same names as those of the original files, but they are stored in a separate <span class="code">projects/10/ExpressionlessSquare</span> directory.

</p><p class="project_text">
<b><u><b>Array Test:</b></u></b> a single-class Jack program designed to test how the syntax analyzer handles array processing:
</p>

<table class="tests">
<tbody><tr class="tstheader">
	<td> Source class file </td>
	<td> Description (quite irrelevant to this project)</td> 
	<td> Tokenizer output </td> 
	<td> Parser output </td>
</tr>
<tr>
	<td>  <a onmouseover="popup(&quot;projects/10/ArrayTest/Main.jack&quot;,true);"> Main.jack </a>  </td>
	<td> Computes the average of a user-supplied sequence of integers 
	     using an array data structure and array manipulation commands.</td>
	<td> <a onmouseover="popup(&quot;projects/10/ArrayTest/MainT.xml&quot;,true);"> MainT.xml </a> </td>
	<td> <a onmouseover="popup(&quot;projects/10/ArrayTest/Main.xml&quot;,true);"> Main.xml </a> </td>
</tr>
</tbody></table>

<p class="project_text">
<b>Experimenting with the test programs:</b> if you want, you can compile the supplied <i>SquareDance</i> and <i>TestArray</i> programs using the supplied <i>Jack compiler</i>, then use the supplied <i>VM emulator</i> to run the compiled code. This activity is irrelevant to the current project. However, it serves to show that the test programs are not just plain text; they also have semantics, or meaning, something that the syntax analyzer does not care about.
</p>

<span class="project_desc">Testing</span>

<p class="project_text">
<b>Tokenizer Testing:</b>
</p>
<ul>
	<li> Test your tokenizer on the <i>Square Dance</i> and the <i>TestArray</i> programs. </li>
	<li> For each <span class="code">Xxx.jack</span> source file, have your tokenizer test program give the output file the name <span class="code">XxxT.xml</span>. Apply your tokenizer test to each class file in the test programs, then use the supplied <span class="code">TextComparer</span> utility to compare the generated output to the supplied <span class="code">.xml</span> compare files.</li>
	<li> Since the output files generated by your tokenizer test will have the same names and extensions as those of the supplied compare files, we suggest putting them in separate directories.</li> 
</ul>

<p class="project_text">
<b>Parser Testing:</b>
</p>

<ul>
	<li> Apply your syntax analyzer to the supplied test programs, then use the supplied <span class="code">TextComparer</span> utility to compare the generated output to the supplied <span class="code">.xml</span> compare files.</li>
	<li> Since the output files generated by your syntax analyzer will have the same names and extensions as those of the supplied compare files, we suggest putting them in separate directories.</li> 
	<li> Note that the indentation of the XML output is only for readability. Web browsers and the supplied <i>TextComparer</i> ignore white space.</li> 
</ul>
<p></p>
			</div>
		</div>
		<div class="small">
			Best viewed with 
							<img src="./The Elements of Computing Systems _ Nisan &amp; Schocken_files/compatible_firefox.gif">
							<img src="./The Elements of Computing Systems _ Nisan &amp; Schocken_files/compatible_chrome.gif"><br>
			Designed and built by Tali Gutman ©
		</div>
	
	
</body></html>