#!bash


# to use , vi ~/.profile, add...
# myProfile=~/".myProfile" 
# if [ -L "$myProfile" ]
# then
#     source $myProfile
# fi

# check your bash script:  https://www.shellcheck.net/

export LC_ALL=en_US.UTF-8


# ========================== PROXY =================================
ret=`lsof -i:3128`
if [ -n "$ret" ] ; then
    # proxy tunnel is running
    # for authenticate proxy
    #   use cntlm 
    # for non-auth proxy
    #   brew install samuong/alpaca/alpaca
    #   brew services start alpaca
    #   launchd: ~/Library/LaunchAgents/homebrew.mxcl.alpaca.plist
    #      change alpaca path , and restart ??
    #   log: /usr/local/var/log/alpaca.log
    export _proxy=127.0.0.1:3128

    export  http_proxy=http://$_proxy
    export https_proxy=http://$_proxy
    export  HTTP_PROXY=$http_proxy
    export HTTPS_PROXY=$https_proxy

    #u3d proxy ?
    export  HTTP_proxy=$http_proxy
    export HTTPS_proxy=$https_proxy

    export NO_PROXY="localhost,127.0.0.1,10.192.*,192.168.*,10.242.*,kubernetes.docker.internal,wpad"
    export no_proxy=$NO_PROXY
fi

# ========================== Functions =================================

# manim shortcut
manim() {
    docker run --rm -it  --user="$(id -u):$(id -g)" -v "$(pwd)":/manim manimcommunity/manim:stable manim $@
}

# t2s 
t2sgen() {
    if [ "$#" -lt 3 ]; then
        echo 'usage: t2sgen key body.json dst_file_name'
    else
        curl -sL -X POST -H "content-type:application/json" "https://texttospeech.googleapis.com/v1beta1/text:synthesize?key=$1" -d @$2  | python3 -c "import sys,json;print(json.loads(''.join([l for l in sys.stdin]))['audioContent'])" | base64 -D  > $3.mp3
    fi
}


# grep  implies grep -G
# egrep implies grep -E
#
# There are two interpretations of the syntax in regex patterns. The difference is in the behavior of a few special characters, ?, +, (), {}, and |.
#
# BRE (Basic Regular Expression) – these characters do not have special meaning unless prefixed with a backslash \.
# ERE (Extended Regular Expression) – these characters are special, unless prefixed with a backslash \.

# deprecated, use myfind instead
myfind2() {
    if [ "$#" -lt 1 ]; then
        echo 'usage: myfind [-opts]* "pattern" [path] [-opts]'
        echo 'grep options supported'
        echo e.g. 'myfind -m 4 -C 2 "ab test" -wh'
    else
        local  _opt="" 
        local _path="."
        local _pattern=""

        # check all parameters one by one
        while [ $# != 0 ]
        do
            # if parameter startswith `-` 
            if [[ $1 == -* ]] ; then
                if [[ $1 != *=* ]] ; then
                    # if not contains `=`, then shift and read its value
                    _opt="$_opt $1"
                    # if $# > 1, then
                    if [ $# -gt 1 ]; then
                        shift
                        # quote it
                        _opt="${_opt} "`printf "%q\n" "$1"`
                    fi
                else
                    # if contains `=`
                    # string before `=` and `=`
                    _opt="$_opt ${1%%=*}="
                    # quote string after `=`
                    _opt="${_opt}"`printf "%q\n" "${1#*=}"`
                fi
            else
                if [ -z "$_pattern" ]; then
                    _pattern=`printf "%q\n" "$1"`
                else
                    _path=`printf "%q\n" "$1"`
                fi
            fi

            shift
        done

        # --exclude-dir=.git \
        # --exclude-dir=.\*_output \
        #
        # --exclude-dir='./.*'  is to ignore all hidden folders starts with `.`
        # echo 'opts:' "$_opt" #, 'pattern:' "$_pattern", 'path:' "$_path"
        #
        #  'use -E to switch egrep mode on MacOSX'
        bash -c "grep -E --color=always -rinI -m 1 \
            --exclude-dir=node_modules \
            --exclude-dir='./.*'    \
            --exclude=\*.{log,} \
            --exclude=\*.min.{js,} \
            $_opt -e $_pattern $_path"
    fi
}

# ========================== BREW =================================

# sbin
export PATH="$PATH:/usr/local/sbin"
# brew path
if [ "$(uname)" = "Linux" ]; then
    _brewBin="/home/linuxbrew/.linuxbrew/bin"
    # if exists $_brewBin, and not in $PATH, then add it
    if [ -d "$_brewBin" ] && [[ ":$PATH:" != *":$_brewBin:"* ]]; then
        export PATH="$_brewBin":$PATH
    fi
fi

# Linux, let /usr/local/bin has higher priority than /homebrew
export PATH="/usr/local/bin:$PATH"


# ========================== JAVA =================================

# if OS is darwin
if [ "$(uname)" = "Darwin" ]; then
    # Multiple JAVA versions
    export JAVA_8_HOME=$(/usr/libexec/java_home -v1.8.0_)
    export JAVA_11_HOME=$(/usr/libexec/java_home -v11)
    export JAVA_17_HOME=$(/usr/libexec/java_home -v17)

    # can switch java version by alias easily
    alias java8='export JAVA_HOME=$JAVA_8_HOME'
    alias java11='export JAVA_HOME=$JAVA_11_HOME'
    alias java17='export JAVA_HOME=$JAVA_17_HOME'

    #default java17
    export JAVA_HOME=$JAVA_17_HOME
else
    # if exists $_jenv_bin, and not in $PATH, then add it
    if command -v jenv &> /dev/null; then
        eval "$(jenv init -)"
        # for jdk in openjdk@8 openjdk@11 openjdk@17 , print brew --prefix $jdk
        for jdk in openjdk@8 openjdk@11 openjdk@17
        do
            _jdkpath="$(brew --prefix $jdk)"
            # if jdk is not added in jenv versions
            # then add it
            if [ -d "$_jdkpath" ]; then
                jenv add $_jdkpath > /dev/null
            fi
            unset _jdkpath
        done
        jenv global 17
    fi
fi


# ========================== GO =================================
if command -v brew &> /dev/null; then
    export GOROOT="$(brew --prefix go)/libexec"
fi

export PATH=$PATH:"$HOME/go/bin"
export GO111MODULE=on


# ========================== MISC =================================
# pyenv
if [ "$(uname)" = "Darwin" ]; then
    export PYTHON_CONFIGURE_OPTS="--enable-framework"
fi

if command -v pyenv &> /dev/null; then
    # export PATH="$HOME/.pyenv/versions/`cat $HOME/.pyenv/version`/bin":$PATH
    export PATH="$HOME/.pyenv/shims":$PATH
    export PATH=`pyenv prefix`/bin:$PATH
fi

# PATH: /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin

alias so="source ~/.profile"

# x11
if [ "$(uname)" = "Darwin" ]; then

    _display_number=`ps -ef | grep "Xquartz :\d" | grep -v xinit | awk '{ print $9; }'`
    # if _display_number is not empty, then set DISPLAY
    if [ -n "$_display_number" ]; then
         _ip=`ifconfig en0 | grep inet | awk '$1=="inet" {print $2}'` 
        xhost + $_ip  &> /dev/null
        xhost + localhost &> /dev/null
        export DISPLAY=$_ip$_display_number
        export DISPLAY_L=host.docker.internal$_display_number
        unset _ip
    else
        unset DISPLAY
    fi
    unset _display_number

fi

# shinker.py 
if [ "$(uname)" = "Darwin" ]; then
    pathShinker=`mdfind -onlyin /Volumes/WORK  -name shinker.py 2>/dev/null`
    if [ -n "$pathShinker" ]; then
        alias shinker="python3 $pathShinker"
    fi
fi



myProfileGrep=~/".myProfileGrep"
if [ -L "$myProfileGrep" ]
then
    source $myProfileGrep
fi

myProfileYtdl=~/".myProfileYtdl"
if [ -L "$myProfileYtdl" ]
then
    source $myProfileYtdl
fi




# if exists "$HOME/.cargo/env", source it, else echo warning
if [ -f "$HOME/.cargo/env" ]; then
   source "$HOME/.cargo/env"
else
  echo "Warning: $HOME/.cargo/env not found."
  echo "Please install rustup-init"
fi


alias ycmd-install="( cd ~/.vim/plugged/YouCompleteMe && ./install.py --all && rm -rf third_party/ycmd/third_party/tern_runtime/node_modules )"
alias my-blame='git blame  --color-lines --color-by-age  -w -C -C -C -M -M -M '
alias mdfind='mdfind 2> /dev/null '

