#!bash

# do NOT put `#` in pythong code
_pyArgStr='
import sys
import re

RE_DOULB_UNDERLINE_ARG = re.compile(r"^(--[a-zA-Z0-9-]+=)(.*)?$")

if __name__ == "__main__":
    args = []
    patterns = []
    i = 1
    while i < len(sys.argv):
        arg = sys.argv[i]
        if arg.startswith("--"):
            if "=" not in arg:
                args.append(arg)
            elif RE_DOULB_UNDERLINE_ARG.match(arg):
                # repr() the capture group to escape backslashes
                args.append(
                    RE_DOULB_UNDERLINE_ARG.sub(
                        lambda m: m.group(1) + repr(m.group(2)), arg
                    )
                )

        elif arg.startswith("-"):
            args.append(arg)
            nextArg = i + 1 < len(sys.argv) and sys.argv[i + 1] or None
            if nextArg is not None and not nextArg.startswith("-"):
                args.append(nextArg)
                i += 1
        else:
            patterns.append(repr(arg))

        i += 1

    print("", " ".join(args), " ".join(patterns))
'


# grep  implies grep -G
# egrep implies grep -E
# grep -P implies Perl-compatible regex, support lookahead/lookbehind , but is not POSIX standard  (?!...), (?<=...), etc., also support greedy and non-greedy quantifiers .*? , .+?, named capture groups (?P<name>...), etc. On MacOS, grep -P may not be available by default.
#
# There are two interpretations of the syntax in regex patterns. The difference is in the behavior of a few special characters, ?, +, (), {}, and |.
#
# BRE (Basic Regular Expression) – these characters do not have special meaning unless prefixed with a backslash \.
# ERE (Extended Regular Expression) – these characters are special, unless prefixed with a backslash \.

mygfind() {
    if [ "$#" -lt 1 ]; then
        echo 'usage: myfind [grep-ops]* "pattern" [path]'
        echo e.g. 'myfind -m 4 -C 2  -wh' "ab test"
        echo 'adv 1: find files include both pattern A and B'
        echo '  myfind A -l | xargs  grep --color=always -m 1 -n B'
        echo 'adv 2: find lines include both pattern A and B'
        echo '  myfind A | grep -i B'
        echo 'provide -G if you want to use BRE'
        echo 'use grep -v to Reverse/Exclude patterns'
    else
        grep -E --color=always -rinI -m 1 \
            --exclude-dir='node_modules*' \
            --exclude-dir=.nyc_output \
            --exclude-dir='./.*'    \
            --exclude=\*.{log,} \
            --exclude=\*.min.{js,} \
            "$@" \
            | cut -c1-300
    fi
}

myfind () {
    # if `rg` not exists, use mygfind
    if ! command -v rg >/dev/null 2>&1; then
        mygfind "$@"
        return $?
    fi

  if [ "$#" -lt 1 ]; then
    echo 'usage: myrg [rg-ops]* "pattern" [path]'
    echo 'e.g. myrg -m 20 -C 4 "ab test" .'
    echo 'tip: use -F for fixed-string, -uuu to ignore ignore-files'
    return 1
  fi
  # 默认输出 path:line:match
  # 如果开了 --column，rg 会变成 path:line:col:match
  rg --no-heading -H -n -i --color=always \
     -m 1 \
     --max-columns 300 \
     --max-columns-preview \
     --glob '!node_modules*/**' \
     --glob '!.nyc_output/**' \
     --glob '!*.log' \
     --glob '!*.min.js' \
     "$@"
}

myFE() {
    # execute  myfind ... -l | xargs nvim -p
    myfind "$@" --color=auto --colors 'path:none' -l | xargs nvim -p
}

