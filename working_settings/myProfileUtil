#!bash

myCompressPdf() {
    # compress_pdf_aggressive.sh
    # ç”¨æ³•: ./compress_pdf_aggressive.sh input.pdf output.pdf
    # æé™å‹ç¼©ï¼š/screen è®¾ç½® + åˆ†å— + å¹¶è¡Œ

    INPUT="$1"
    OUTPUT="$2"
    BLOCK_SIZE=50           # æ¯å—é¡µæ•°ï¼Œå¯è°ƒ
if [ `uname` = "Linux" ];
then
    CPU_CORES=$(nproc)      # Linux
else
    CPU_CORES=$(sysctl -n hw.ncpu)
fi

    tmpdir="./pdftmp"
    rm -rf "$tmpdir"
    mkdir -p "$tmpdir"
    echo "ä¸´æ—¶ç›®å½•: $tmpdir"

    # 1ï¸âƒ£ åˆ†å‰² PDF
    echo "æ­£åœ¨åˆ†å‰² PDF..."
    qpdf "$INPUT" --split-pages=1-50 "$tmpdir/part.pdf"


    xargs_extra_args="-n1"
    if [ `uname` = "Linux" ];
      echo ${xargs_extra_args}
    then
      xargs_extra_args=""
    fi


    # 2ï¸âƒ£ å¹¶è¡Œå‹ç¼©æ¯å—ï¼ˆæ›´å°ä½“ç§¯ï¼Œä½è´¨é‡ï¼‰
    echo "æ­£åœ¨å‹ç¼©åˆ†å— PDFï¼ˆæé™å‹ç¼©ï¼‰..."
    ls "$tmpdir"/part-*.pdf | xargs ${xargs_extra_args} -P"$CPU_CORES" -I{} gs -sDEVICE=pdfwrite \
       -dCompatibilityLevel=1.4 \
       \
       -dPDFSETTINGS=/ebook \
       \
       -dDownsampleColorImages=true \
       -dDownsampleGrayImages=true \
       -dDownsampleMonoImages=true \
       \
       -dColorImageResolution=120 \
       -dGrayImageResolution=120 \
       -dMonoImageResolution=600 \
       \
       -dAutoFilterColorImages=true \
       -dAutoFilterGrayImages=true \
       \
       -dDetectDuplicateImages=true \
       -dCompressFonts=true \
       -dSubsetFonts=true \
       -dEmbedAllFonts=true \
       \
        -dNOPAUSE -dQUIET -dBATCH -sOutputFile="{}"_compressed "{}"


    # 3ï¸âƒ£ åˆå¹¶å‹ç¼©åçš„ PDF
    echo "æ­£åœ¨åˆå¹¶ PDF..."
    qpdf --empty --pages "$tmpdir"/part-*.pdf_compressed -- "$OUTPUT"

    # 4ï¸âƒ£ æ¸…ç†ä¸´æ—¶æ–‡ä»¶
    rm -rf "$tmpdir"
    echo "å®Œæˆ! è¾“å‡ºæ–‡ä»¶: $OUTPUT"
}


function ts2date() {
    # if is Darwin
    if [ -z "$1" ]; then
        TZ=UTC date "+%Y-%m-%d %H:%M:%S %Z"
    else
        ts=$1
        # å¦‚æœ tsæ˜¯æ¯«ç§’ï¼Œè½¬æ¢ä¸ºç§’
        if [ $ts -gt 1000000000000 ]; then
            ts=$(($ts / 1000))
        fi
        if [ `uname` = "Darwin" ]; then
            TZ=UTC date -r $ts "+%Y-%m-%d %H:%M:%S %Z"
        else
            TZ=UTC date -d @"ts" "+%Y-%m-%d %H:%M:%S %Z"
        fi
    fi
}

function date2ts() {
    # if $1 is not provided, use current date
    if [ -z "$1" ]; then
        date +%s
    else
        # æŒ‡å®šè¾“å…¥æ•°æ® æ—¶åŒºä¸º UTC
        if [ `uname` = "Darwin" ]; then
            TZ=UTC date -j -f "%Y-%m-%d %H:%M:%S" $1 "+%s"
        else
            TZ=UTC date -d "$1" "+%s"
        fi
    fi
}

function json2literal() {
    if [[ -t 0 && -f "$1" ]]; then
        # å¦‚æœæœ‰æ–‡ä»¶å‚æ•°
        python3 -c 'import sys,json; print(json.dumps( json.dumps(json.load(open("'$1'")),ensure_ascii=False), ensure_ascii=False))'
    else
        # å¦åˆ™ä» stdin è¯»
        python3 -c 'import sys,json; print(json.dumps( json.dumps(json.load(sys.stdin),ensure_ascii=False), ensure_ascii=False))'
    fi
}

myProclist () {
	procName="$1" 
	if [ -z "$procName" ]
	then
		echo "Usage: proclist procName"
		return 1
	fi
	pgrep -f $procName | xargs -I {} ps -p {} -o pid,ppid,user,group,tty,%cpu,%mem,rss,command
}

alias bat="bat --theme dark"

# login to k8s pod with fzf selection
function myl2pod() {
    # k_jd -n dev
    args=("$@")
    # it may contain alias, expand alias
    expanded_args=()
    for arg in "${args[@]}"; do
        # echo $arg
        # which whether arg is an alias, if so replace the alias name with its value
        alias_value=$(alias $arg 2>/dev/null | sed -E "s/$arg='(.*)'/\1/")
        if [ -n "$alias_value" ]; then
            expanded_args+=("$alias_value")
        else
            expanded_args+=("$arg")
        fi
    done
    # echo "Logging into pod: ${expanded_args[*]}"

    # 1 é€‰æ‹© pod
    pod=$(
        bash -c "${expanded_args[*]} get po --no-headers " |
        fzf |
        awk '{print $1}'
    )

    [ -z "$pod" ] && return

    # 2 è·å– container åˆ—è¡¨
    containers=($(
        bash -c "${expanded_args[*]} get po $pod -o jsonpath='{.spec.containers[*].name}'"
    ))
    # echo "Containers in pod $pod: ${containers[*]}"

    # 3. å¦‚æœæœ‰å¤šä¸ª containerï¼Œé€‰æ‹©ä¸€ä¸ª
    if [ "${#containers[*]}" -eq 1 ]; then
        container=${containers[*]}
    else
        container=$(printf '%s\n' "${containers[@]}" | fzf)
        [ -z "$container" ] && return
    fi

    # ğŸ”¥ å…³é”®ç‚¹ï¼šstdin/stdout/stderr æ¥å› tty
    # ç®¡é“é‡Œçš„ stdin åªæ˜¯ä¸€æ ¹ pipeï¼Œä¸æ˜¯ç»ˆç«¯
    # kubectl çœ‹åˆ°çš„æ˜¯ï¼šstdin = pipe
    # è¦ç”¨å½“å‰ç”¨æˆ·çœŸæ­£çš„ç»ˆç«¯ä½œä¸º stdin 
    #     /dev/tty = å½“å‰ shell æ‰€å±çš„çœŸå®ç»ˆç«¯
    #     å³ä½¿ä½ åœ¨ç®¡é“é‡Œï¼Œä¹Ÿèƒ½å¼ºè¡Œâ€œæ’å›å»â€
    # è¿™æ˜¯å¤„ç† fzf + exec + interactive program çš„é€šç”¨è§£æ³•ã€‚
    #
    # 4 exec è¿›å…¥ pod + container
    bash -c "${expanded_args[*]} exec -it $pod -c "$container" -- /bin/bash" </dev/tty
}


# use ramdisk as tmp dir on macOS
ramDisk="/Volumes/RamDisk"
temDir="${ramDisk}/TEMPDIR"
if [ -d "$ramDisk" ] ; then
    # if tmp dir not exists, create it
    if [ ! -d "$temDir" ] ; then
        mkdir -p "$temDir"
    fi

    export TMPDIR=$temDir
    cleanTmpDir() {
        if [ -d "$temDir" ] ; then
            find "$temDir" -type f -mtime +7 -delete
        fi
    }
fi

# ç”¨äº slog æ—¥å¿—è¾“å‡ºç¾åŒ–
alias slog='jq -Rr '"'"'
def color_level(l):
  if l=="ERROR" then "\u001b[31m"
  elif l=="WARN" then "\u001b[33m"
  elif l=="INFO" then "\u001b[32m"
  elif l=="DEBUG" then "\u001b[36m"
  else "" end;

def color_msg(s):
  "\u001b[36m" + s + "\u001b[0m";  # cyan

(fromjson? // .) |
if type=="object" then
  "\(.time // "") " +
  (color_level(.level) + "[\(.level // "")]\u001b[0m ") +
  (color_msg(.msg // "")) +
  (del(.time,.level,.msg) | if .=={} then "" else " " + tojson end)
else
  .
end
'"'"

